这种题目就是在两个维度上排序，本题要求的是将所有人放在正确的位置上，也就是比他高或者一样高的人数和第二位一样。
那么这种双标准的排序一般都需要先确定其中一个维度的排序：一般这种数对，还涉及排序的，根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。

在本题目中，我首先对数对进行排序，按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，保证最后插入时身高一样的在正确位置。

********其中用到了一个sort.Slice函数，第一个参数是被排序的切片，第二个参数则是排序的内嵌方法，i表示后一个元素，j表示前一个元素的序号，当返回值是true时交换位置，所以要把条件写为期待得到的对立操作。比如要得到递增序列，那么条件就是return xxx[i]< xxx[j]，也就是后面如果比前面小就交换，最后就可以得到递增序列********


先排序，再插队思想的代码：
func reconstructQueue(people [][]int) [][]int {
	// 1. sort by height
	// 2. insert by k
	// 3. return
	sort.Slice(people, func(i, j int) bool {
		if people[i][0] == people[j][0] { // 当前后两个元素的身高相等时，按照k升序排列，i代表后一个元素，j代表前一个元素，结果为true时，交换位置。后一个元素比前一个元素小时，交换位置，最后结果就是升序排列。
			return people[i][1] < people[j][1]
		}
		return people[i][0] > people[j][0] // 按照身高降序排列，i代表后一个元素，j代表前一个元素，结果为true时，交换位置。后一个元素比前一个元素大时，交换位置，最后结果就是降序排列。
	})
	var res [][]int
	for _, p := range people { // 遍历people, p代表people的每一个元素
		if len(res) <= p[1] { // 如果res的长度小于等于p[1]，则直接将p加入到res中
			res = append(res, p)
			continue
		}
		// 如果res的长度大于p[1]，则将p插入到res的p[1]位置
		res = append(res, []int{})
		copy(res[p[1]+1:], res[p[1]:]) // 将res[p[1]:]的值复制到res[p[1]+1:]中
		res[p[1]] = p
	}
	return res

}

此题是一个困难题，看似难度特别高，但是由于前面关于数组的题目我都是用哈希表完成的，所以这一题第一反应也是用哈希表，反而几行代码就解决了，也将复杂度控制在o（n）。
思路很简单，建立一个map[int]int来记录每个数字出现次数，遍历数组给哈希表赋值。结束后从1开始循环一个数组的长度来找第一个没有被赋值的正整数就是最小缺失正整数。
值得注意的是，当遍历了整个数组长度依然都没有最小缺失的数出现，那最小的就是下一个新的整数。

func firstMissingPositive(nums []int) int {
	//使用哈希表统计每个数字出现的次数
	m := make(map[int]int)
	for _, v := range nums {
		m[v]++
	}
	//从1开始遍历，如果哈希表中不存在该数字，则返回该数字
	for i := 1; i <= len(nums); i++ {
		if _, ok := m[i]; !ok { //不存在
			return i
		}
	}
	return len(nums) + 1 //如果1到len(nums)都存在，则返回len(nums)+1

}

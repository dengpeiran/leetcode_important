这一题和448题形成对比，448题不限制时间复杂度，所以会有一种执行起来更快的方法：交换数组。但是本题规定了时间复杂度时，用交换数组的方式不仅会超时，而且会多次遍历数组。

448题的第二种解法就是用哈希表记录每个数组出现次数后，在遍历哈希表，本题一样的逻辑，只需要在遍历的时候把判断条件改为value值为2即可：

func findDuplicates(nums []int) []int {
	//使用哈希表统计
	var res []int
	m := make(map[int]int)
	for _, v := range nums {
		m[v]++
	}
	for i := 1; i <= len(nums); i++ {
		if  m[i] == 2 {
			res = append(res, i)
		}
	}
	return res

}


-------值得一提的是：有时候会发现虽然用哈希表时间复杂度低，但是其执行时间并不低，甚至会超过用数组的方法，这是因为哈希表低层的扩容机制，当开了一个任意大小的哈希表后，对其的扩容操作会触发堆栈遍历，这会消耗很多时间。---------
